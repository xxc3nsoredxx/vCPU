vCPU documentation:
    
Each instruction is 64bits in size. Each executable will thus be 8-byte aligned.

Type sizes:
    byte:   8  bits
    word:   16 bits
    dword:  32 bits
    qword:  64 bits

Instruction format:
    aaaa bbbb cccc dddd
    +----|----|----|------instruction locator
         +----|----|------parameter 1
              +----|------parameter 2
                   |------parameter 3

Error flags:
    Bit set means error, clear means OK.

    bit 00 - RAM allocation error

Opcodes:
    * means wildcard/unused
    nop         - 0000 **** **** ****
    addr        - 0001 00** 00** 00**
                         +----|----|----result register
                              +----|----register to add
                                   +----register to add
    addi        - 0002 00** **** ****
                         +--|----|------result register
                            +----|------bytes 4-3
                                 +------bytes 1-0
    sri         - 0003 00** **** ****
                         +--|----|------result register
                            +----|------bytes 4-3
                                 +------bytes 1-0
    sli         - 0004 00** **** ****
                         +--|----|------result register
                            +----|------bytes 4-3
                                 +------bytes 1-0
    srr         - 0005 00** 00** 00**
                         +----|----|----result register
                              +----|----register to shift
                                   +----register with shift amount
    slr         - 0006 00** 00** 00**
                         +----|----|----result register
                              +----|----register to shift
                                   +----register with shift amount

Instructions:
    nop             - no operatrion
    addr  a b c     - add registers: a = b + c
    addi  a b c     - add immediate to register: a = b.c
                      if the number is bigger than b and c concatenated
                      then the second half is or'ed in after shifting the
                      first half (must be implemented by the assembler)
    sri   a b c     - shift a register right by immediate value: a >>= b.c
    sli   a b c     - shift a register left by immediate value: a <<= b.c
    srr   a b c     - shift shift register b right by the value stored in 
                      register c, store result in register a: a = b >> c
    slr   a b c     - shift shift register b left by the value stored in 
                      register c, store result in register a: a = b << c
